<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Escape the Maze</title>
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --accent:#7c3aed; --wall:#e6eef8; --avatar:#ffb86b; --finish:#34d399;
      --font: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071028);color:var(--wall);font-family:var(--font);overflow-x:hidden;overscroll-behavior-x:none}
    body{touch-action:pan-y}
    .app{display:grid;grid-template-columns:1fr 320px;gap:20px;min-height:100vh;padding:28px}
    .canvas-wrap{background:linear-gradient(180deg,#06122433,#06122411);padding:18px;border-radius:12px;display:flex;flex-direction:column;align-items:center;justify-content:center;touch-action:none}
    canvas{background:#0b1220;border-radius:8px;box-shadow:0 6px 30px rgba(0,0,0,0.6);touch-action:none}
    .panel{background:linear-gradient(180deg,#071428,#02101b);padding:18px;border-radius:12px;min-height:320px;display:flex;flex-direction:column;gap:12px}
    h1{font-size:18px;margin:0 0 6px 0;color:var(--accent)}
    .meta{font-size:13px;color:#9fb1d0}
    .stat{background:rgba(255,255,255,0.03);padding:10px;border-radius:8px}
    .big{font-size:22px;font-weight:600;color:var(--wall)}
    button{appearance:none;border:0;padding:10px 12px;border-radius:8px;background:var(--accent);color:white;font-weight:600;cursor:pointer}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--wall)}
    .controls{display:flex;gap:8px}
    .hint{font-size:12px;color:#9fb1d0}
    .footer{margin-top:auto;font-size:12px;color:#6f8aa8}
    .small{font-size:12px;color:#9fb1d0}
    .score{display:flex;gap:8px;align-items:center}
    .badge{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px}

    /* Landing page */
    .hidden{display:none}
    .landing{min-height:100vh;padding:28px;display:grid;grid-template-columns:1fr;gap:28px;align-items:center;place-items:center;position:relative;isolation:isolate}
    .landing .hero{background:linear-gradient(180deg,#071428,#02101b);border:1px solid rgba(255,255,255,0.06);padding:28px;border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,0.5);max-width:920px;width:100%;text-align:center}
    .landing h1{font-size:42px;line-height:1.1;margin:0 0 12px 0;color:var(--wall)}
    .landing .accent{color:var(--accent)}
    .landing .subtitle{color:#9fb1d0;font-size:16px;margin-bottom:18px}
    .landing .story{color:#c6d4ea;font-size:15px;margin:0 0 18px 0}
    .landing .cta{display:flex;gap:10px;align-items:center;justify-content:center;margin-top:16px}
    .landing .cta .primary{padding:18px 26px;font-size:18px;border-radius:14px;background:linear-gradient(135deg,var(--accent),#9b5cf1);box-shadow:0 12px 28px rgba(124,58,237,0.4);transition:transform .15s ease, box-shadow .2s ease}
    .landing .cta .primary:hover{transform:translateY(-1px);box-shadow:0 16px 36px rgba(124,58,237,0.45)}
    .landing .cta .secondary{border:1px solid rgba(255,255,255,0.06)}
    .landing .cards{display:grid;grid-template-columns:repeat(2,minmax(260px,1fr));gap:12px;margin-top:16px;justify-items:center;max-width:560px;margin-left:auto;margin-right:auto}
    .landing .card{background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.06);padding:14px;border-radius:12px;text-align:center}
    .landing .card .title{color:var(--wall);font-weight:700;margin-bottom:6px}
    .landing .card .text{color:#9fb1d0;font-size:13px}
    /* Roadmap */
    .landing .roadmap{margin-top:24px}
    .landing .roadmap h2{margin:8px 0 12px 0;font-size:24px;color:var(--wall)}
    .landing .timeline{position:relative;margin:0 auto;max-width:900px;padding:12px 0;display:grid;grid-template-columns:1fr;gap:12px}
    .landing .step{display:grid;grid-template-columns:28px 1fr;gap:12px;align-items:start;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.06);padding:12px;border-radius:12px}
    .landing .dot{width:28px;height:28px;border-radius:50%;background:linear-gradient(135deg,var(--accent),#9b5cf1);display:flex;align-items:center;justify-content:center;color:white;font-weight:800;box-shadow:0 10px 24px rgba(124,58,237,0.35)}
    .landing .step .title{color:var(--wall);font-weight:700;margin-bottom:4px}
    .landing .step .desc{color:#9fb1d0;font-size:13px}
    .landing .roadmap-footer{margin-top:10px;color:#9fb1d0;font-size:13px}
    .landing .preview{background:radial-gradient(120% 100% at 10% 0%, rgba(124,58,237,0.35), transparent), linear-gradient(180deg,#061224,#0b1220);border:1px solid rgba(255,255,255,0.06);border-radius:16px;padding:18px;position:relative;overflow:hidden;min-height:380px;display:flex;align-items:end}
    .landing .preview::after{content:"";position:absolute;inset:-20%;background:radial-gradient(40% 30% at 70% 10%, rgba(124,58,237,0.25), transparent), radial-gradient(30% 20% at 30% 90%, rgba(52,211,153,0.18), transparent);filter:blur(18px);z-index:0}
    .landing .preview .mock{position:relative;z-index:1;width:100%;aspect-ratio:1/1;border-radius:12px;background:#0b1220;box-shadow:0 10px 40px rgba(0,0,0,0.6), inset 0 0 0 1px rgba(255,255,255,0.05);display:grid;grid-template-columns:repeat(7,1fr);grid-auto-rows:1fr;gap:6px;padding:12px}
    .landing .cell{background:rgba(230,238,248,0.08);border-radius:6px}
    .landing .cell.finish{background:rgba(52,211,153,0.9)}
    .landing .cell.player{background:rgba(255,184,107,0.98)}
    .landing .meta-info{position:absolute;top:18px;left:18px;background:rgba(0,0,0,0.35);backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,0.08);padding:8px 10px;border-radius:10px;color:#c6d4ea;font-size:12px;z-index:2}
    .landing .glow{position:absolute;inset:-10%;background:radial-gradient(50% 40% at 20% 10%, rgba(124,58,237,0.16), transparent), radial-gradient(40% 35% at 80% 80%, rgba(52,211,153,0.12), transparent);filter:blur(30px);z-index:-1}
    .landing .eyebrow{color:#9fb1d0;text-transform:uppercase;letter-spacing:.14em;font-size:11px;margin-bottom:8px}
    .landing .list{display:grid;gap:8px;margin-top:8px}

    @keyframes floaty{0%{transform:translateY(0)}50%{transform:translateY(-6px)}100%{transform:translateY(0)}}
    .landing .mock{animation:floaty 6s ease-in-out infinite}

    /* Mobile header */
    .mobile-header{display:none;align-items:center;justify-content:space-between;padding:8px 12px;margin-bottom:8px;background:linear-gradient(180deg,#071428,#02101b);border-radius:12px}
    .mh-title{font-size:16px;font-weight:700;color:var(--accent)}
    .mh-timer{font-size:16px;font-weight:700;color:var(--wall)}

    /* Static joystick under canvas (mobile) */
    .joystick{display:none;margin-top:12px}
    .joy-grid{display:grid;grid-template-columns:72px 72px 72px;grid-template-rows:72px 72px 72px;gap:10px}
    .joy-btn{width:72px;height:72px;border-radius:15px;border:2px solid rgba(124,58,237,0.45);background:radial-gradient(120px 120px at 30% 30%, rgba(124,58,237,0.35), rgba(7,16,32,0.7));color:#ffffff;font-size:26px;font-weight:700;display:flex;align-items:center;justify-content:center;box-shadow:0 10px 24px rgba(124,58,237,0.32), inset 0 1px 0 rgba(255,255,255,0.06)}
    .joy-btn:active{transform:scale(0.98);box-shadow:0 6px 18px rgba(124,58,237,0.4), inset 0 1px 0 rgba(255,255,255,0.08)}
    .joy-btn:focus-visible{outline:none;box-shadow:0 0 0 3px rgba(124,58,237,0.6), 0 10px 24px rgba(124,58,237,0.32)}

    /* Modal */
    .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);z-index:100}
    .modal.show{display:flex}
    .modal-card{background:linear-gradient(180deg,#071428,#02101b);border:1px solid rgba(255,255,255,0.08);padding:20px;border-radius:12px;min-width:260px;max-width:92vw;color:var(--wall);text-align:center}
    .modal-card h2{margin:0 0 8px 0;color:var(--accent);font-size:20px}
    .modal-actions{display:flex;gap:8px;justify-content:center;margin-top:12px}

    @media (max-width: 900px){
      .app{grid-template-columns:1fr;padding:16px;gap:12px}
      .mobile-header{display:flex}
      .panel h1{display:none}
      .panel .timer-card{display:none}
      .canvas-wrap{order:2;padding:12px}
      .panel{order:2}
      canvas{width:100%;height:auto}
      .controls{flex-wrap:wrap}
      .joystick{display:flex;justify-content:center}
      .panel button{font-size:16px;padding:12px 16px}
      .landing{grid-template-columns:1fr;gap:16px;padding:16px}
      .landing h1{font-size:32px}
      .landing .cards{grid-template-columns:1fr 1fr}
    }

    /* Desktop zigzag timeline */
    @media (min-width: 900px){
      .landing .timeline{grid-template-columns:1fr 1fr;gap:18px 32px}
      .landing .timeline::before{content:"";position:absolute;top:0;bottom:0;left:50%;width:2px;background:rgba(255,255,255,0.08);transform:translateX(-1px)}
      .landing .step{max-width:420px}
      .landing .step:nth-child(odd){grid-column:1;justify-self:end}
      .landing .step:nth-child(even){grid-column:2;justify-self:start}
    }

    /* Narrow screens: slightly smaller joystick to fit */
    @media (max-width: 420px){
      .joy-grid{grid-template-columns:60px 60px 60px;grid-template-rows:60px 60px 60px;gap:10px}
      .joy-btn{width:60px;height:60px;font-size:22px;border-radius:12px}
      .landing .cards{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
  <!-- Marketing landing -->
  <div class="landing" id="landing">
    <div class="hero">
      <div class="eyebrow">inmaze</div>
      <h1><span class="accent">Escape</span> the Maze: choose your path, beat the clock</h1>
      <div class="subtitle">Every wall is a riddle. Every move is a choice. Can you find the perfect route and finish faster than the clock?</div>
      <p class="story">In the neon hush of Inmaze, the walls follow a logic of their own. They bend your perception, hide the shortest lines, and test your calm. Your mission: reach the green tile as efficiently as possible. Step by step, toward the finish.</p>
      <div class="cards">
        <div class="card"><div class="title">Mission</div><div class="text">Outsmart the maze. Train focus and pattern recognition, and feel the rush of nailing the perfect line before the timer bites.</div></div>
        <div class="card"><div class="title">Goal</div><div class="text">Reach the finish via the shortest route—earn a bonus and a crisp sense of control.</div></div>
      </div>
      <div class="cta">
        <button id="startGameBtn" class="primary">Start Game</button>
      </div>
      <div class="roadmap">
        <h2>Roadmap</h2>
        <div class="timeline">
          <div class="step">
            <div class="dot">1</div>
            <div>
              <div class="title">Daily challenges</div>
              <div class="desc">Rotating mazes with global seed, one shot per day, shareable results.</div>
            </div>
          </div>
          <div class="step">
            <div class="dot">2</div>
            <div>
              <div class="title">Leaderboards</div>
              <div class="desc">Best times by day and all-time, friends filter, anti-cheat validation.</div>
            </div>
          </div>
          <div class="step">
            <div class="dot">3</div>
            <div>
              <div class="title">Skins & themes</div>
              <div class="desc">Unlockable avatars and maze skins matching the neon aesthetic.</div>
            </div>
          </div>
          <div class="step">
            <div class="dot">4</div>
            <div>
              <div class="title">Advanced modes</div>
              <div class="desc">Fog-of-war, time-attack, no-turn-back, and path-memory training.</div>
            </div>
          </div>
          <div class="step">
            <div class="dot">5</div>
            <div>
              <div class="title">Co-op & races</div>
              <div class="desc">Real-time races on identical seeds, spectate friends, emoji reactions.</div>
            </div>
          </div>
        </div>
        <div class="roadmap-footer">To be continued…</div>
      </div>
    </div>
  </div>

  <div class="app hidden" id="app">
    <!-- Mobile header -->
    <div class="mobile-header">
      <div class="mh-title">Escape the Maze</div>
      <div id="timerTop" class="mh-timer">00:00.000</div>
    </div>
    <div class="canvas-wrap">
      <canvas id="mazeCanvas" width="720" height="720" tabindex="0" aria-label="Maze canvas"></canvas>
      <!-- Static joystick (mobile) -->
      <div class="joystick" aria-label="Joystick" role="group">
        <div class="joy-grid">
          <div></div>
          <button class="joy-btn" id="joyUp" aria-label="Up">▲</button>
          <div></div>
          <button class="joy-btn" id="joyLeft" aria-label="Left">◀</button>
          <div></div>
          <button class="joy-btn" id="joyRight" aria-label="Right">▶</button>
          <div></div>
          <button class="joy-btn" id="joyDown" aria-label="Down">▼</button>
          <div></div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div>
        <h1>Escape the Maze</h1>
        <div class="meta">Use arrow keys (desktop) or swipe / on-screen arrows (mobile). Reach the green tile to finish.</div>
      </div>

      <div class="stat timer-card">
        <div class="small">Timer</div>
        <div id="timer" class="big">00:00.000</div>
      </div>

      <div class="stat">
        <div class="small">Moves</div>
        <div id="moves" class="big">0</div>
      </div>

      <div class="stat">
        <div class="small">Shortest path (cells)</div>
        <div id="shortest" class="big">—</div>
      </div>

      <div class="stat score">
        <div>
          <div class="small">Bonus</div>
          <div id="bonus" class="big">—</div>
        </div>
        <div style="margin-left:auto">
          <button id="replayBtn">Replay (new maze)</button>
        </div>
      </div>

      <div class="hint">Tip: Timer starts on your first move. If you reach the finish using the shortest possible number of steps you get a bonus time deduction.</div>

      <div class="controls">
        <button id="showPath" class="secondary">Show shortest path</button>
        <button id="hidePath" class="secondary">Hide path</button>
      </div>

      <div class="footer">
        <div class="small">Generated maze uses randomized depth-first algorithm. Avatar: orange circle. Finish tile: green square.</div>
      </div>
    </div>
  </div>

  <!-- Finish modal -->
  <div class="modal" id="finishModal" aria-modal="true" role="dialog">
    <div class="modal-card">
      <h2>Escaped!</h2>
      <div id="finishText" class="small">You made it.</div>
      <div class="modal-actions">
        <button id="playAgainBtn">Replay</button>
      </div>
    </div>
  </div>

  <script>
    // Escape the Maze - single file
    (function(){
      const canvas = document.getElementById('mazeCanvas');
      const ctx = canvas.getContext('2d');
      const timerEl = document.getElementById('timer');
      const timerTopEl = document.getElementById('timerTop');
      const movesEl = document.getElementById('moves');
      const shortestEl = document.getElementById('shortest');
      const bonusEl = document.getElementById('bonus');
      const replayBtn = document.getElementById('replayBtn');
      const showPathBtn = document.getElementById('showPath');
      const hidePathBtn = document.getElementById('hidePath');
      const landingEl = document.getElementById('landing');
      const appEl = document.getElementById('app');
      const startGameBtn = document.getElementById('startGameBtn');

      // Maze settings - adapt to canvas size
      let COLS = 21; // odd numbers produce symmetric mazes
      let ROWS = 21;
      const PADDING = 6;

      let cellSize; // pixels

      let grid; // 2D array of cells
      let stack = [];

      // Player state
      let player = { r:1, c:1, steps:0 };
      let start = { r:1, c:1 };
      let finish = { r: ROWS-2, c: COLS-2 };

      // Path and shortest
      let shortestPath = null;
      let showShortest = false;

      // Timer
      let startTime = null;
      let running = false;
      let timerRAF = null;

      // Helpers
      function cellIndex(r,c){ return r*COLS + c; }

      function initSizes(){
        // Fit canvas to available space (CSS) and scale internal pixels for crispness
        const dpr = window.devicePixelRatio || 1;
        const wrap = canvas.parentElement;
        const rect = wrap.getBoundingClientRect();
        // leave some vertical room for UI on small screens
        const reserved = window.innerWidth<=900 ? 320 : 220; // reserve space for header/joystick on mobile
        const maxCss = Math.min(rect.width || 720, Math.max(320, (window.innerHeight - reserved)));
        const targetCssSize = Math.max(240, Math.floor(maxCss));
        canvas.style.width = targetCssSize + 'px';
        canvas.style.height = targetCssSize + 'px';
        // internal resolution
        const pixelSize = Math.floor(targetCssSize * dpr);
        // compute cell size that fits neatly within internal pixels
        cellSize = Math.floor((pixelSize - PADDING*2) / Math.max(ROWS, COLS));
        canvas.width = cellSize * COLS + PADDING*2;
        canvas.height = cellSize * ROWS + PADDING*2;
      }

      function makeGrid(){
        grid = Array.from({length:ROWS}, (_,r)=>Array.from({length:COLS}, (_,c)=>({
          r,c,
          walls:[true,true,true,true], // top,right,bottom,left
          visited:false
        })));
      }

      function neighbors(r,c){
        const dirs = [ [-2,0,0],[0,2,1],[2,0,2],[0,-2,3] ];
        const out = [];
        for(const [dr,dc,dir] of dirs){
          const nr=r+dr, nc=c+dc;
          if(nr>0 && nr<ROWS && nc>0 && nc<COLS) out.push({r:nr,c:nc,dir});
        }
        return out;
      }

      function carveBetween(a,b){
        const mr = (a.r + b.r)/2 | 0;
        const mc = (a.c + b.c)/2 | 0;
        // remove walls between
        // a -> mid
        removeWall(a, {r:mr,c:mc});
        removeWall({r:mr,c:mc}, a);
        removeWall(b, {r:mr,c:mc});
        removeWall({r:mr,c:mc}, b);
      }

      function removeWall(a,b){
        const dr=b.r-a.r, dc=b.c-a.c;
        const cellA = grid[a.r][a.c];
        if(dr===-1) cellA.walls[0]=false; // top
        if(dc===1) cellA.walls[1]=false; // right
        if(dr===1) cellA.walls[2]=false; // bottom
        if(dc===-1) cellA.walls[3]=false; // left
      }

      // Generate maze using randomized DFS (recursive backtracker) on an odd-cell grid
      function generateMaze(){
        initSizes();
        makeGrid();
        // prepare barrier grid: make every even coordinate a wall cell; carve passages on odd coords
        // We'll perform DFS starting at start
        for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) grid[r][c].visited=false;

        const stack = [];
        const s = grid[start.r][start.c];
        s.visited=true;
        stack.push(s);

        while(stack.length){
          const current = stack[stack.length-1];
          const nbrs = neighbors(current.r,current.c).filter(n=> !grid[n.r][n.c].visited);
          if(nbrs.length===0){
            stack.pop();
          } else {
            const nxt = nbrs[Math.floor(Math.random()*nbrs.length)];
            // carve through the middle cell
            carveBetween(current, grid[nxt.r][nxt.c]);
            grid[nxt.r][nxt.c].visited = true;
            stack.push(grid[nxt.r][nxt.c]);
          }
        }

        // After generation, set walls for edge cells that remain walls
        // For consistent drawing, compute walls for every cell (including middle wall cells)
        // We'll derive walls from neighbors and carved passages: If there's no passage to neighbor -> wall exists
        for(let r=0;r<ROWS;r++){
          for(let c=0;c<COLS;c++){
            const cell = grid[r][c];
            // If cell is a wall coordinate (even coordinates), keep walls all true
            // But our generation carved passages at odd coordinates and mid cells, walls array already set logically
            // ensure bounds
            if(r===0) cell.walls[0]=true;
            if(c===COLS-1) cell.walls[1]=true;
            if(r===ROWS-1) cell.walls[2]=true;
            if(c===0) cell.walls[3]=true;
          }
        }

        // Recompute finish to be bottom-right passage cell
        finish = { r: ROWS-2, c: COLS-2 };
        player = { r:start.r, c:start.c, steps:0 };

        // Compute shortest path with BFS
        shortestPath = computeShortestPath();
        shortestEl.textContent = shortestPath ? shortestPath.length-1 : '—';

        draw();
      }

      function computeShortestPath(){
        // BFS on grid allowing moves between adjacent passage cells (not cross walls)
        const visited = Array.from({length:ROWS}, ()=>Array(COLS).fill(false));
        const prev = Array.from({length:ROWS}, ()=>Array(COLS).fill(null));
        const q=[];
        q.push(start);
        visited[start.r][start.c]=true;
        while(q.length){
          const cur = q.shift();
          if(cur.r===finish.r && cur.c===finish.c) break;
          const dirs = [[-1,0],[0,1],[1,0],[0,-1]];
          for(const [dr,dc] of dirs){
            const nr=cur.r+dr, nc=cur.c+dc;
            if(nr<0||nc<0||nr>=ROWS||nc>=COLS) continue;
            if(visited[nr][nc]) continue;
            // check if passage between cur and neighbor exists (no wall on cur toward that neighbor)
            const wallBetween = isWallBetween(cur.r,cur.c,nr,nc);
            if(wallBetween) continue;
            visited[nr][nc]=true;
            prev[nr][nc]=cur;
            q.push({r:nr,c:nc});
          }
        }
        if(!visited[finish.r][finish.c]) return null;
        // reconstruct path
        const path=[];
        let cur = finish;
        while(cur){ path.push(cur); cur = prev[cur.r][cur.c]; }
        return path.reverse();
      }

      function isWallBetween(r1,c1,r2,c2){
        const dr = r2-r1, dc = c2-c1;
        // if dr == -1 => r2 above r1 -> check r1 top wall
        const cell = grid[r1][c1];
        if(dr===-1) return cell.walls[0];
        if(dc===1) return cell.walls[1];
        if(dr===1) return cell.walls[2];
        if(dc===-1) return cell.walls[3];
        return true;
      }

      function draw(){
        if(!grid){ return; }
        ctx.clearRect(0,0,canvas.width,canvas.height);
        // background
        ctx.fillStyle = '#071126';
        ctx.fillRect(0,0,canvas.width,canvas.height);

        // translate to padding
        ctx.save();
        ctx.translate(PADDING,PADDING);

        // draw cells
        ctx.lineWidth = Math.max(2, Math.floor(cellSize*0.12));
        for(let r=0;r<ROWS;r++){
          for(let c=0;c<COLS;c++){
            const x=c*cellSize, y=r*cellSize;
            const cell = grid[r][c];
            // draw floor for passage-like cells (heuristic)
            // we'll consider a cell 'passage' if any wall missing
            const isPassage = cell.walls.some(w=>!w);
            if(isPassage){
              ctx.fillStyle = '#071a2b';
              ctx.fillRect(x,y,cellSize,cellSize);
            }
            ctx.strokeStyle = 'rgba(230,238,248,0.95)';
            // draw walls
            ctx.beginPath();
            if(cell.walls[0]){ ctx.moveTo(x,y); ctx.lineTo(x+cellSize,y); }
            if(cell.walls[1]){ ctx.moveTo(x+cellSize,y); ctx.lineTo(x+cellSize,y+cellSize); }
            if(cell.walls[2]){ ctx.moveTo(x+cellSize,y+cellSize); ctx.lineTo(x,y+cellSize); }
            if(cell.walls[3]){ ctx.moveTo(x,y+cellSize); ctx.lineTo(x,y); }
            ctx.stroke();
          }
        }

        // optionally draw shortest path
        if(showShortest && shortestPath){
          ctx.lineWidth = Math.max(2, Math.floor(cellSize*0.2));
          ctx.beginPath();
          for(let i=0;i<shortestPath.length;i++){
            const p = shortestPath[i];
            const cx = p.c*cellSize + cellSize/2, cy = p.r*cellSize + cellSize/2;
            if(i===0) ctx.moveTo(cx,cy); else ctx.lineTo(cx,cy);
          }
          ctx.strokeStyle = 'rgba(52,211,153,0.9)';
          ctx.stroke();
        }

        // draw finish tile
        ctx.fillStyle = 'rgba(52,211,153,0.95)';
        ctx.fillRect(finish.c*cellSize+cellSize*0.15, finish.r*cellSize+cellSize*0.15, cellSize*0.7, cellSize*0.7);

        // draw player avatar
        const px = player.c*cellSize + cellSize/2;
        const py = player.r*cellSize + cellSize/2;
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,184,107,0.98)';
        ctx.arc(px,py, Math.max(6,cellSize*0.28), 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        // update UI
        movesEl.textContent = player.steps;
      }

      function movePlayer(dr,dc){
        const nr = player.r + dr, nc = player.c + dc;
        if(nr<0||nc<0||nr>=ROWS||nc>=COLS) return;
        if(isWallBetween(player.r, player.c, nr, nc)) return;
        player.r = nr; player.c = nc; player.steps++;
        if(!running){ startTimer(); }
        draw();
        checkFinish();
      }

      function checkFinish(){
        if(player.r===finish.r && player.c===finish.c){
          stopTimer();
          // compute bonus: if player.steps <= shortestPath.length-1 then award bonus as 20% of time saved
          let msg='No bonus';
          if(shortestPath){
            const minSteps = shortestPath.length-1;
            if(player.steps <= minSteps){
              // success on shortest
              const elapsed = performance.now() - startTime;
              const bonusMS = Math.max(0, Math.floor(elapsed * 0.2));
              msg = `Shortest! -${formatTime(bonusMS)} bonus`;
            } else {
              const over = player.steps - minSteps;
              msg = `+${over} steps over shortest`;
            }
          }
          bonusEl.textContent = msg;
          // show modal
          const modal = document.getElementById('finishModal');
          const text = document.getElementById('finishText');
          text.innerHTML = `Finished in ${timerEl.textContent}<br>${msg}`;
          modal.classList.add('show');
        }
      }

      function startTimer(){
        if(running) return;
        running = true;
        startTime = performance.now();
        function tick(){
          if(!running) return;
          const elapsed = performance.now() - startTime;
          timerEl.textContent = formatTime(elapsed);
          if(timerTopEl) timerTopEl.textContent = timerEl.textContent;
          timerRAF = requestAnimationFrame(tick);
        }
        timerRAF = requestAnimationFrame(tick);
      }

      function stopTimer(){
        running = false;
        if(timerRAF) cancelAnimationFrame(timerRAF);
      }

      function resetTimer(){
        stopTimer(); startTime = null; timerEl.textContent = '00:00.000'; if(timerTopEl) timerTopEl.textContent = '00:00.000';
      }

      function formatTime(ms){
        if(ms==null) return '00:00.000';
        const total = Math.max(0, ms|0);
        const minutes = Math.floor(total/60000);
        const seconds = Math.floor((total%60000)/1000);
        const msecs = total%1000;
        return `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}.${String(msecs).padStart(3,'0')}`;
      }

      function flashMessage(text, ms=2000){
        const prev = document.title;
        document.title = text;
        setTimeout(()=>document.title = prev, ms);
      }

      // key handling
      window.addEventListener('keydown', (e)=>{
        const keys = ['ArrowUp','ArrowRight','ArrowDown','ArrowLeft','Up','Down','Left','Right'];
        if(!keys.includes(e.key)) return;
        e.preventDefault();
        if(e.key==='ArrowUp' || e.key==='Up') movePlayer(-1,0);
        if(e.key==='ArrowRight' || e.key==='Right') movePlayer(0,1);
        if(e.key==='ArrowDown' || e.key==='Down') movePlayer(1,0);
        if(e.key==='ArrowLeft' || e.key==='Left') movePlayer(0,-1);
      }, {passive:false});

      // touch swipe handling
      let touchStart = null;
      canvas.addEventListener('touchstart', (e)=>{
        if(e.touches && e.touches.length>0){
          const t = e.touches[0];
          touchStart = {x:t.clientX, y:t.clientY};
        }
        e.preventDefault();
        canvas.focus();
      }, {passive:false});
      canvas.addEventListener('touchmove', (e)=>{
        // prevent page scroll while swiping on canvas
        e.preventDefault();
      }, {passive:false});
      canvas.addEventListener('touchend', (e)=>{
        if(!touchStart){ return; }
        const t = (e.changedTouches && e.changedTouches[0]) || null;
        if(t){
          const dx = t.clientX - touchStart.x;
          const dy = t.clientY - touchStart.y;
          const absX = Math.abs(dx), absY = Math.abs(dy);
          const threshold = 24; // px
          if(absX>threshold || absY>threshold){
            if(absX>absY){
              if(dx>0) movePlayer(0,1); else movePlayer(0,-1);
            } else {
              if(dy>0) movePlayer(1,0); else movePlayer(-1,0);
            }
          }
        }
        touchStart = null;
        e.preventDefault();
      }, {passive:false});

      // UI buttons
      replayBtn.addEventListener('click', ()=>{
        // regenerate maze
        resetTimer(); bonusEl.textContent='—'; movesEl.textContent='0'; shortestEl.textContent='—';
        // randomize size a bit for variety
        const sizes = [21,23,25,27];
        const pick = sizes[Math.floor(Math.random()*sizes.length)];
        ROWS = COLS = pick;
        start = {r:1,c:1};
        generateMaze();
      });

      showPathBtn.addEventListener('click', ()=>{ showShortest=true; draw(); });
      hidePathBtn.addEventListener('click', ()=>{ showShortest=false; draw(); });

      // Landing interactions
      if(startGameBtn){
        startGameBtn.addEventListener('click', ()=>{
          landingEl.classList.add('hidden');
          appEl.classList.remove('hidden');
          // ensure sizes/layout ok when showing
          initSizes();
          draw();
          canvas.focus();
          flashMessage('Good luck! Find the shortest path', 1800);
        });
      }

      // Static joystick buttons with hold-to-repeat
      const joyUp = document.getElementById('joyUp');
      const joyRight = document.getElementById('joyRight');
      const joyDown = document.getElementById('joyDown');
      const joyLeft = document.getElementById('joyLeft');
      function bindHold(btn, dr, dc){
        if(!btn) return;
        let holdTimer=null, repeatTimer=null;
        const step = ()=> movePlayer(dr,dc);
        const start = (e)=>{
          e.preventDefault();
          canvas.focus();
          step();
          clearTimeout(holdTimer); clearInterval(repeatTimer);
          holdTimer = setTimeout(()=>{
            repeatTimer = setInterval(step, 140);
          }, 260);
        };
        const end = ()=>{ clearTimeout(holdTimer); clearInterval(repeatTimer); holdTimer=null; repeatTimer=null; };
        btn.addEventListener('mousedown', start);
        btn.addEventListener('touchstart', start, {passive:false});
        window.addEventListener('mouseup', end);
        btn.addEventListener('touchend', end);
        btn.addEventListener('touchcancel', end);
        btn.addEventListener('mouseleave', end);
        btn.addEventListener('contextmenu', (e)=>e.preventDefault());
      }
      bindHold(joyUp, -1, 0);
      bindHold(joyRight, 0, 1);
      bindHold(joyDown, 1, 0);
      bindHold(joyLeft, 0, -1);

      // Modal controls
      const modal = document.getElementById('finishModal');
      const playAgainBtn = document.getElementById('playAgainBtn');
      function closeModal(){ modal.classList.remove('show'); }
      playAgainBtn.addEventListener('click', ()=>{ closeModal(); replayBtn.click(); });

      // initialize (pre-generate, игра скрыта до старта)
      generateMaze();

      // compute shortest path initially
      function resizeAndRedraw(){ initSizes(); draw(); }
      window.addEventListener('resize', resizeAndRedraw);

      // expose simple touch controls (optional): clicking near avatar moves
      canvas.addEventListener('click', (ev)=>{
        // focus to capture keys
        canvas.focus();
      });

      // initial focus
      canvas.focus();

    })();
  </script>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
  (function(m,e,t,r,i,k,a){
      m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
      m[i].l=1*new Date();
      for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
      k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
  })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=103954416', 'ym');

  ym(103954416, 'init', {ssr:true, webvisor:true, clickmap:true, ecommerce:"dataLayer", accurateTrackBounce:true, trackLinks:true});
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/103954416" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
</body>
</html>
